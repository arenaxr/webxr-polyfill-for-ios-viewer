/**
 * @license
 * webxr-polyfill
 * Copyright (c) 2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * cardboard-vr-display
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * webvr-polyfill-dpdb 
 * Copyright (c) 2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * wglu-preserve-state
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * nosleep.js
 * Copyright (c) 2017, Rich Tibbett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.WebXRPolyfill=t()}(this,function(){"use strict";const e="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},t=Symbol("@@webxr-polyfill/EventTarget");class i{constructor(){this[t]={listeners:new Map}}addEventListener(e,i){if("string"!=typeof e)throw new Error("`type` must be a string");if("function"!=typeof i)throw new Error("`listener` must be a function");const n=this[t].listeners.get(e)||[];n.push(i),this[t].listeners.set(e,n)}removeEventListener(e,i){if("string"!=typeof e)throw new Error("`type` must be a string");if("function"!=typeof i)throw new Error("`listener` must be a function");const n=this[t].listeners.get(e)||[];for(let e=n.length;e>=0;e--)n[e]===i&&n.pop()}dispatchEvent(e,i){const n=this[t].listeners.get(e)||[],r=[];for(let e=0;e<n.length;e++)r[e]=n[e];for(let e of r)e(i);"function"==typeof this[`on${e}`]&&this[`on${e}`](i)}}const n=1e-6;let r="undefined"!=typeof Float32Array?Float32Array:Array;Math.PI;function s(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function o(e,t){let i=t[0],n=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],p=t[11],f=t[12],v=t[13],m=t[14],w=t[15],g=i*a-n*o,S=i*l-r*o,y=i*c-s*o,b=n*l-r*a,x=n*c-s*a,R=r*c-s*l,E=h*v-u*f,F=h*m-d*f,M=h*w-p*f,P=u*m-d*v,X=u*w-p*v,O=d*w-p*m,_=g*O-S*X+y*P+b*M-x*F+R*E;return _?(_=1/_,e[0]=(a*O-l*X+c*P)*_,e[1]=(r*X-n*O-s*P)*_,e[2]=(v*R-m*x+w*b)*_,e[3]=(d*x-u*R-p*b)*_,e[4]=(l*M-o*O-c*F)*_,e[5]=(i*O-r*M+s*F)*_,e[6]=(m*y-f*R-w*S)*_,e[7]=(h*R-d*y+p*S)*_,e[8]=(o*X-a*M+c*E)*_,e[9]=(n*M-i*X-s*E)*_,e[10]=(f*x-v*y+w*g)*_,e[11]=(u*y-h*x-p*g)*_,e[12]=(a*F-o*P-l*E)*_,e[13]=(i*P-n*F+r*E)*_,e[14]=(v*S-f*b-m*g)*_,e[15]=(h*b-u*S+d*g)*_,e):null}function a(e,t,i){let n=t[0],r=t[1],s=t[2],o=t[3],a=t[4],l=t[5],c=t[6],h=t[7],u=t[8],d=t[9],p=t[10],f=t[11],v=t[12],m=t[13],w=t[14],g=t[15],S=i[0],y=i[1],b=i[2],x=i[3];return e[0]=S*n+y*a+b*u+x*v,e[1]=S*r+y*l+b*d+x*m,e[2]=S*s+y*c+b*p+x*w,e[3]=S*o+y*h+b*f+x*g,S=i[4],y=i[5],b=i[6],x=i[7],e[4]=S*n+y*a+b*u+x*v,e[5]=S*r+y*l+b*d+x*m,e[6]=S*s+y*c+b*p+x*w,e[7]=S*o+y*h+b*f+x*g,S=i[8],y=i[9],b=i[10],x=i[11],e[8]=S*n+y*a+b*u+x*v,e[9]=S*r+y*l+b*d+x*m,e[10]=S*s+y*c+b*p+x*w,e[11]=S*o+y*h+b*f+x*g,S=i[12],y=i[13],b=i[14],x=i[15],e[12]=S*n+y*a+b*u+x*v,e[13]=S*r+y*l+b*d+x*m,e[14]=S*s+y*c+b*p+x*w,e[15]=S*o+y*h+b*f+x*g,e}function l(){let e=new r(3);return r!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function c(e,t,i){let n=new r(3);return n[0]=e,n[1]=t,n[2]=i,n}function h(e,t,i){let n=t[0],r=t[1],s=t[2],o=i[0],a=i[1],l=i[2];return e[0]=r*l-s*a,e[1]=s*o-n*l,e[2]=n*a-r*o,e}const u=function(e){let t=e[0],i=e[1],n=e[2];return Math.sqrt(t*t+i*i+n*n)};!function(){let e=l()}();!function(){let e=function(){let e=new r(4);return r!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}()}();function d(){let e=new r(4);return r!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function p(e,t,i,r){let s,o,a,l,c,h=t[0],u=t[1],d=t[2],p=t[3],f=i[0],v=i[1],m=i[2],w=i[3];return(o=h*f+u*v+d*m+p*w)<0&&(o=-o,f=-f,v=-v,m=-m,w=-w),1-o>n?(s=Math.acos(o),a=Math.sin(s),l=Math.sin((1-r)*s)/a,c=Math.sin(r*s)/a):(l=1-r,c=r),e[0]=l*h+c*f,e[1]=l*u+c*v,e[2]=l*d+c*m,e[3]=l*p+c*w,e}const f=function(e,t,i,n){let s=new r(4);return s[0]=e,s[1]=t,s[2]=i,s[3]=n,s},v=function(e,t){let i=t[0],n=t[1],r=t[2],s=t[3],o=i*i+n*n+r*r+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=i*o,e[1]=n*o,e[2]=r*o,e[3]=s*o),e},m=(function(){let e=l(),t=c(1,0,0),i=c(0,1,0)}(),function(){let e=d(),t=d()}(),function(){let e=function(){let e=new r(9);return r!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}()}(),Symbol("@@webxr-polyfill/XRRigidTransform"));class w{constructor(){if(this[m]={matrix:null,position:null,orientation:null,inverse:null},0===arguments.length)this[m].matrix=s(new Float32Array(16));else if(1===arguments.length)arguments[0]instanceof Float32Array?this[m].matrix=arguments[0]:(this[m].position=this._getPoint(arguments[0]),this[m].orientation=DOMPointReadOnly.fromPoint({x:0,y:0,z:0,w:1}));else{if(2!==arguments.length)throw new Error("Too many arguments!");this[m].position=this._getPoint(arguments[0]),this[m].orientation=this._getPoint(arguments[1])}if(this[m].matrix){let i=l();e=i,t=this[m].matrix,e[0]=t[12],e[1]=t[13],e[2]=t[14],this[m].position=DOMPointReadOnly.fromPoint({x:i[0],y:i[1],z:i[2]});let n=d();!function(e,t){let i=t[0]+t[5]+t[10],n=0;i>0?(n=2*Math.sqrt(i+1),e[3]=.25*n,e[0]=(t[6]-t[9])/n,e[1]=(t[8]-t[2])/n,e[2]=(t[1]-t[4])/n):t[0]>t[5]&&t[0]>t[10]?(n=2*Math.sqrt(1+t[0]-t[5]-t[10]),e[3]=(t[6]-t[9])/n,e[0]=.25*n,e[1]=(t[1]+t[4])/n,e[2]=(t[8]+t[2])/n):t[5]>t[10]?(n=2*Math.sqrt(1+t[5]-t[0]-t[10]),e[3]=(t[8]-t[2])/n,e[0]=(t[1]+t[4])/n,e[1]=.25*n,e[2]=(t[6]+t[9])/n):(n=2*Math.sqrt(1+t[10]-t[0]-t[5]),e[3]=(t[1]-t[4])/n,e[0]=(t[8]+t[2])/n,e[1]=(t[6]+t[9])/n,e[2]=.25*n)}(n,this[m].matrix),this[m].orientation=DOMPointReadOnly.fromPoint({x:n[0],y:n[1],z:n[2],w:n[3]})}else this[m].matrix=s(new Float32Array(16)),function(e,t,i){let n=t[0],r=t[1],s=t[2],o=t[3],a=n+n,l=r+r,c=s+s,h=n*a,u=n*l,d=n*c,p=r*l,f=r*c,v=s*c,m=o*a,w=o*l,g=o*c;e[0]=1-(p+v),e[1]=u+g,e[2]=d-w,e[3]=0,e[4]=u-g,e[5]=1-(h+v),e[6]=f+m,e[7]=0,e[8]=d+w,e[9]=f-m,e[10]=1-(h+p),e[11]=0,e[12]=i[0],e[13]=i[1],e[14]=i[2],e[15]=1}(this[m].matrix,f(this[m].orientation.x,this[m].orientation.y,this[m].orientation.z,this[m].orientation.w),c(this[m].position.x,this[m].position.y,this[m].position.z));var e,t}_getPoint(e){return e instanceof DOMPointReadOnly?e:DOMPointReadOnly.fromPoint(e)}get matrix(){return this[m].matrix}get position(){return this[m].position}get orientation(){return this[m].orientation}get inverse(){if(null===this[m].inverse){let e=s(new Float32Array(16));o(e,this[m].matrix),this[m].inverse=new w(e),this[m].inverse[m].inverse=this}return this[m].inverse}}const g=Symbol("@@webxr-polyfill/XRSpace");class S{constructor(e=null,t=null){this[g]={specialType:e,inputSource:t,baseMatrix:null,inverseBaseMatrix:null,lastFrameId:-1}}get _specialType(){return this[g].specialType}get _inputSource(){return this[g].inputSource}_ensurePoseUpdated(e,t){t!=this[g].lastFrameId&&(this[g].lastFrameId=t,this._onPoseUpdate(e))}_onPoseUpdate(e){"viewer"==this[g].specialType&&(this._baseMatrix=e.getBasePoseMatrix())}set _baseMatrix(e){this[g].baseMatrix=e,this[g].inverseBaseMatrix=null}get _baseMatrix(){return this[g].baseMatrix||this[g].inverseBaseMatrix&&(this[g].baseMatrix=new Float32Array(16),o(this[g].baseMatrix,this[g].inverseBaseMatrix)),this[g].baseMatrix}set _inverseBaseMatrix(e){this[g].inverseBaseMatrix=e,this[g].baseMatrix=null}get _inverseBaseMatrix(){return this[g].inverseBaseMatrix||this[g].baseMatrix&&(this[g].inverseBaseMatrix=new Float32Array(16),o(this[g].inverseBaseMatrix,this[g].baseMatrix)),this[g].inverseBaseMatrix}_getSpaceRelativeTransform(e){if(!this._inverseBaseMatrix||!e._baseMatrix)return null;let t=new Float32Array(16);return a(t,this._inverseBaseMatrix,e._baseMatrix),new w(t)}}const y=1.6,b=Symbol("@@webxr-polyfill/XRReferenceSpace"),x=["viewer","local","local-floor","bounded-floor","unbounded"];class R extends S{constructor(e,t=null){if(!x.includes(e))throw new Error(`XRReferenceSpaceType must be one of ${x}`);if(super(e),"bounded-floor"===e&&!t)throw new Error("XRReferenceSpace cannot use 'bounded-floor' type if the platform does not provide the floor level");(function(e){return"bounded-floor"===e||"local-floor"===e})(e)&&!t&&((t=s(new Float32Array(16)))[13]=y),this._inverseBaseMatrix=t||s(new Float32Array(16)),this[b]={type:e,transform:t,originOffset:s(new Float32Array(16))}}_transformBasePoseMatrix(e,t){a(e,this._inverseBaseMatrix,t)}_originOffsetMatrix(){return this[b].originOffset}_adjustForOriginOffset(e){let t=new Float32Array(16);o(t,this[b].originOffset),a(e,t,e)}_getSpaceRelativeTransform(e){let t=super._getSpaceRelativeTransform(e);return this._adjustForOriginOffset(t.matrix),new XRRigidTransform(t.matrix)}getOffsetReferenceSpace(e){let t=new R(this[b].type,this[b].transform,this[b].bounds);return a(t[b].originOffset,this[b].originOffset,e.matrix),t}}const E=Symbol("@@webxr-polyfill/XR"),F=["inline","immersive-vr","immersive-ar"],M={inline:{requiredFeatures:["viewer"],optionalFeatures:[]},"immersive-vr":{requiredFeatures:["viewer","local"],optionalFeatures:[]},"immersive-ar":{requiredFeatures:["viewer","local"],optionalFeatures:[]}},P="Polyfill Error: Must call navigator.xr.isSessionSupported() with any XRSessionMode\nor navigator.xr.requestSession('inline') prior to requesting an immersive\nsession. This is a limitation specific to the WebXR Polyfill and does not apply\nto native implementations of the API.";let X;if("performance"in e==!1){let e=Date.now();X=(()=>Date.now()-e)}else X=(()=>performance.now());var O=X;const _=Symbol("@@webxr-polyfill/XRPose");class L{constructor(e,t){this[_]={transform:e,emulatedPosition:t}}get transform(){return this[_].transform}get emulatedPosition(){return this[_].emulatedPosition}}const I=Symbol("@@webxr-polyfill/XRViewerPose");class V extends L{constructor(e,t,i=!1){super(e,i),this[I]={views:t}}get views(){return this[I].views}}const T=Symbol("@@webxr-polyfill/XRViewport");class q{constructor(e){this[T]={target:e}}get x(){return this[T].target.x}get y(){return this[T].target.y}get width(){return this[T].target.width}get height(){return this[T].target.height}}const C=["left","right","none"],D=Symbol("@@webxr-polyfill/XRView");class B{constructor(e,t,i,n){if(!C.includes(i))throw new Error(`XREye must be one of: ${C}`);const r=Object.create(null),s=new q(r);this[D]={device:e,eye:i,viewport:s,temp:r,sessionId:n,transform:t}}get eye(){return this[D].eye}get projectionMatrix(){return this[D].device.getProjectionMatrix(this.eye)}get transform(){return this[D].transform}_getViewport(e){if(this[D].device.getViewport(this[D].sessionId,this.eye,e,this[D].temp))return this[D].viewport}}const j=Symbol("@@webxr-polyfill/XRFrame"),A="XRFrame access outside the callback that produced it is invalid.",k="getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.";let z=0;class W{constructor(e,t,i){this[j]={id:++z,active:!1,animationFrame:!1,device:e,session:t,sessionId:i}}get session(){return this[j].session}getViewerPose(e){if(!this[j].animationFrame)throw new DOMException(k,"InvalidStateError");if(!this[j].active)throw new DOMException(A,"InvalidStateError");const t=this[j].device,i=this[j].session;i[ne].viewerSpace._ensurePoseUpdated(t,this[j].id),e._ensurePoseUpdated(t,this[j].id);let n=e._getSpaceRelativeTransform(i[ne].viewerSpace);const r=[];for(let n of i[ne].viewSpaces){n._ensurePoseUpdated(t,this[j].id);let i=e._getSpaceRelativeTransform(n),s=new B(t,i,n.eye,this[j].sessionId);r.push(s)}return new V(n,r,!1)}getPose(e,t){if(!this[j].active)throw new DOMException(A,"InvalidStateError");const i=this[j].device;if("target-ray"===e._specialType||"grip"===e._specialType)return i.getInputPose(e._inputSource,t,e._specialType);{e._ensurePoseUpdated(i,this[j].id),t._ensurePoseUpdated(i,this[j].id);let n=t._getSpaceRelativeTransform(e);return n?new XRPose(n,!1):null}}}const N=Symbol("@@webxr-polyfill/XRRenderState"),$=Object.freeze({depthNear:.1,depthFar:1e3,inlineVerticalFieldOfView:null,baseLayer:null});class H{constructor(e={}){const t=Object.assign({},$,e);this[N]={config:t}}get depthNear(){return this[N].config.depthNear}get depthFar(){return this[N].config.depthFar}get inlineVerticalFieldOfView(){return this[N].config.inlineVerticalFieldOfView}get baseLayer(){return this[N].config.baseLayer}}const U=Symbol("@@webxr-polyfill/polyfilled-xr-compatible"),G=Symbol("@@webxr-polyfill/xr-compatible"),J=Symbol("@@webxr-polyfill/XRWebGLLayer"),K=Object.freeze({antialias:!0,depth:!1,stencil:!1,alpha:!0,multiview:!1,ignoreDepthValues:!1,framebufferScaleFactor:1});const Q=Symbol("@@webxr-polyfill/XRInputSourceEvent");class Y extends Event{constructor(e,t){super(e,t),this[Q]={frame:t.frame,inputSource:t.inputSource},Object.setPrototypeOf(this,Y.prototype)}get frame(){return this[Q].frame}get inputSource(){return this[Q].inputSource}}const Z=Symbol("@@webxr-polyfill/XRSessionEvent");class ee extends Event{constructor(e,t){super(e,t),this[Z]={session:t.session},Object.setPrototypeOf(this,ee.prototype)}get session(){return this[Z].session}}const te=Symbol("@@webxr-polyfill/XRInputSourcesChangeEvent");class ie extends Event{constructor(e,t){super(e,t),this[te]={session:t.session,added:t.added,removed:t.removed},Object.setPrototypeOf(this,ie.prototype)}get session(){return this[te].session}get added(){return this[te].added}get removed(){return this[te].removed}}const ne=Symbol("@@webxr-polyfill/XRSession");class re extends S{constructor(e){super(e)}get eye(){return this._specialType}_onPoseUpdate(e){this._inverseBaseMatrix=e.getBaseViewMatrix(this._specialType)}}class se extends i{constructor(e,t,i){super();let n="inline"!=t,r=new H({inlineVerticalFieldOfView:n?null:.5*Math.PI});this[ne]={device:e,mode:t,immersive:n,ended:!1,suspended:!1,frameCallbacks:[],currentFrameCallbacks:null,frameHandle:0,deviceFrameHandle:null,id:i,activeRenderState:r,pendingRenderState:null,viewerSpace:new R("viewer"),viewSpaces:[],currentInputSources:[]},n?this[ne].viewSpaces.push(new re("left"),new re("right")):this[ne].viewSpaces.push(new re("none")),this[ne].onDeviceFrame=(()=>{if(this[ne].ended||this[ne].suspended)return;if(this[ne].deviceFrameHandle=null,this[ne].startDeviceFrameLoop(),null!==this[ne].pendingRenderState&&(this[ne].activeRenderState=new H(this[ne].pendingRenderState),this[ne].pendingRenderState=null,this[ne].activeRenderState.baseLayer&&this[ne].device.onBaseLayerSet(this[ne].id,this[ne].activeRenderState.baseLayer)),null===this[ne].activeRenderState.baseLayer)return;const t=new W(e,this,this[ne].id),i=this[ne].currentFrameCallbacks=this[ne].frameCallbacks;this[ne].frameCallbacks=[],t[j].active=!0,t[j].animationFrame=!0,this[ne].device.onFrameStart(this[ne].id,this[ne].activeRenderState),this._checkInputSourcesChange();const n=O();for(let e=0;e<i.length;e++)try{i[e].cancelled||"function"!=typeof i[e].callback||i[e].callback(n,t)}catch(e){console.error(e)}this[ne].currentFrameCallbacks=null,t[j].active=!1,this[ne].device.onFrameEnd(this[ne].id)}),this[ne].startDeviceFrameLoop=(()=>{null===this[ne].deviceFrameHandle&&(this[ne].deviceFrameHandle=this[ne].device.requestAnimationFrame(this[ne].onDeviceFrame))}),this[ne].stopDeviceFrameLoop=(()=>{const e=this[ne].deviceFrameHandle;null!==e&&(this[ne].device.cancelAnimationFrame(e),this[ne].deviceFrameHandle=null)}),this[ne].onPresentationEnd=(t=>{if(t!==this[ne].id)return this[ne].suspended=!1,this[ne].startDeviceFrameLoop(),void this.dispatchEvent("focus",{session:this});this[ne].ended=!0,this[ne].stopDeviceFrameLoop(),e.removeEventListener("@@webxr-polyfill/vr-present-end",this[ne].onPresentationEnd),e.removeEventListener("@@webxr-polyfill/vr-present-start",this[ne].onPresentationStart),e.removeEventListener("@@webxr-polyfill/input-select-start",this[ne].onSelectStart),e.removeEventListener("@@webxr-polyfill/input-select-end",this[ne].onSelectEnd),this.dispatchEvent("end",new ee("end",{session:this}))}),e.addEventListener("@@webxr-polyfill/vr-present-end",this[ne].onPresentationEnd),this[ne].onPresentationStart=(e=>{e!==this[ne].id&&(this[ne].suspended=!0,this[ne].stopDeviceFrameLoop(),this.dispatchEvent("blur",{session:this}))}),e.addEventListener("@@webxr-polyfill/vr-present-start",this[ne].onPresentationStart),this[ne].onSelectStart=(e=>{e.sessionId===this[ne].id&&this[ne].dispatchInputSourceEvent("selectstart",e.inputSource)}),e.addEventListener("@@webxr-polyfill/input-select-start",this[ne].onSelectStart),this[ne].onSelectEnd=(e=>{e.sessionId===this[ne].id&&(this[ne].dispatchInputSourceEvent("selectend",e.inputSource),this[ne].dispatchInputSourceEvent("select",e.inputSource))}),e.addEventListener("@@webxr-polyfill/input-select-end",this[ne].onSelectEnd),this[ne].onSqueezeStart=(e=>{e.sessionId===this[ne].id&&this[ne].dispatchInputSourceEvent("squeezestart",e.inputSource)}),e.addEventListener("@@webxr-polyfill/input-squeeze-start",this[ne].onSqueezeStart),this[ne].onSqueezeEnd=(e=>{e.sessionId===this[ne].id&&(this[ne].dispatchInputSourceEvent("squeezeend",e.inputSource),this[ne].dispatchInputSourceEvent("squeeze",e.inputSource))}),e.addEventListener("@@webxr-polyfill/input-squeeze-end",this[ne].onSqueezeEnd),this[ne].dispatchInputSourceEvent=((t,i)=>{const n=new W(e,this,this[ne].id),r=new Y(t,{frame:n,inputSource:i});n[j].active=!0,this.dispatchEvent(t,r),n[j].active=!1}),this[ne].startDeviceFrameLoop(),this.onblur=void 0,this.onfocus=void 0,this.onresetpose=void 0,this.onend=void 0,this.onselect=void 0,this.onselectstart=void 0,this.onselectend=void 0}get renderState(){return this[ne].activeRenderState}get environmentBlendMode(){return this[ne].device.environmentBlendMode||"opaque"}async requestReferenceSpace(e){if(this[ne].ended)return;if(!x.includes(e))throw new TypeError(`XRReferenceSpaceType must be one of ${x}`);if(!this[ne].device.doesSessionSupportReferenceSpace(this[ne].id,e))throw new DOMException(`The ${e} reference space is not supported by this session.`,"NotSupportedError");if("viewer"===e)return this[ne].viewerSpace;let t=await this[ne].device.requestFrameOfReferenceTransform(e);if("bounded-floor"===e){if(!t)throw new DOMException(`${e} XRReferenceSpace not supported by this device.`,"NotSupportedError");if(!this[ne].device.requestStageBounds())throw new DOMException(`${e} XRReferenceSpace not supported by this device.`,"NotSupportedError");throw new DOMException(`The WebXR polyfill does not support the ${e} reference space yet.`,"NotSupportedError")}return new R(e,t)}requestAnimationFrame(e){if(this[ne].ended)return;const t=++this[ne].frameHandle;return this[ne].frameCallbacks.push({handle:t,callback:e,cancelled:!1}),t}cancelAnimationFrame(e){let t=this[ne].frameCallbacks,i=t.findIndex(t=>t&&t.handle===e);i>-1&&(t[i].cancelled=!0,t.splice(i,1)),(t=this[ne].currentFrameCallbacks)&&(i=t.findIndex(t=>t&&t.handle===e))>-1&&(t[i].cancelled=!0)}get inputSources(){return this[ne].device.getInputSources()}async end(){if(!this[ne].ended)return this[ne].immersive&&(this[ne].ended=!0,this[ne].device.removeEventListener("@@webxr-polyfill/vr-present-start",this[ne].onPresentationStart),this[ne].device.removeEventListener("@@webxr-polyfill/vr-present-end",this[ne].onPresentationEnd),this[ne].device.removeEventListener("@@webxr-polyfill/input-select-start",this[ne].onSelectStart),this[ne].device.removeEventListener("@@webxr-polyfill/input-select-end",this[ne].onSelectEnd),this.dispatchEvent("end",new ee("end",{session:this}))),this[ne].stopDeviceFrameLoop(),this[ne].device.endSession(this[ne].id)}updateRenderState(e){if(this[ne].ended){throw new Error("Can't call updateRenderState on an XRSession that has already ended.")}if(e.baseLayer&&e.baseLayer._session!==this){throw new Error("Called updateRenderState with a base layer that was created by a different session.")}if(null!==e.inlineVerticalFieldOfView&&void 0!==e.inlineVerticalFieldOfView){if(this[ne].immersive){throw new Error("inlineVerticalFieldOfView must not be set for an XRRenderState passed to updateRenderState for an immersive session.")}e.inlineVerticalFieldOfView=Math.min(3.13,Math.max(.01,e.inlineVerticalFieldOfView))}if(null===this[ne].pendingRenderState){const e=this[ne].activeRenderState;this[ne].pendingRenderState={depthNear:e.depthNear,depthFar:e.depthFar,inlineVerticalFieldOfView:e.inlineVerticalFieldOfView,baseLayer:e.baseLayer}}Object.assign(this[ne].pendingRenderState,e)}_checkInputSourcesChange(){const e=[],t=[],i=this.inputSources,n=this[ne].currentInputSources;for(const t of i)n.includes(t)||e.push(t);for(const e of n)i.includes(e)||t.push(e);(e.length>0||t.length>0)&&this.dispatchEvent("inputsourceschange",new ie("inputsourceschange",{session:this,added:e,removed:t})),this[ne].currentInputSources.length=0;for(const e of i)this[ne].currentInputSources.push(e)}}const oe=Symbol("@@webxr-polyfill/XRInputSource");const ae=Symbol("@@webxr-polyfill/XRReferenceSpaceEvent");class le extends Event{constructor(e,t){super(e,t),this[ae]={referenceSpace:t.referenceSpace,transform:t.transform||null},Object.setPrototypeOf(this,le.prototype)}get referenceSpace(){return this[ae].referenceSpace}get transform(){return this[ae].transform}}var ce={XRSystem:class extends i{constructor(e){super(),this[E]={device:null,devicePromise:e,immersiveSession:null,inlineSessions:new Set},e.then(e=>{this[E].device=e})}async isSessionSupported(e){return this[E].device||await this[E].devicePromise,"inline"!=e?Promise.resolve(this[E].device.isSessionSupported(e)):Promise.resolve(!0)}async requestSession(e,t){if(!this[E].device){if("inline"!=e)throw new Error(P);await this[E].devicePromise}if(!F.includes(e))throw new TypeError(`The provided value '${e}' is not a valid enum value of type XRSessionMode`);const i=M[e],n=i.requiredFeatures.concat(t&&t.requiredFeatures?t.requiredFeatures:[]),r=i.optionalFeatures.concat(t&&t.optionalFeatures?t.optionalFeatures:[]),s=new Set;let o=!1;for(let e of n)this[E].device.isFeatureSupported(e)?s.add(e):(console.error(`The required feature '${e}' is not supported`),o=!0);if(o)throw new DOMException("Session does not support some required features","NotSupportedError");for(let e of r)this[E].device.isFeatureSupported(e)?s.add(e):console.log(`The optional feature '${e}' is not supported`);const a=await this[E].device.requestSession(e,s),l=new XRSession(this[E].device,e,a);"inline"==e?this[E].inlineSessions.add(l):this[E].immersiveSession=l;const c=()=>{"inline"==e?this[E].inlineSessions.delete(l):this[E].immersiveSession=null,l.removeEventListener("end",c)};return l.addEventListener("end",c),l}},XRSession:se,XRSessionEvent:ee,XRFrame:W,XRView:B,XRViewport:q,XRViewerPose:V,XRWebGLLayer:class{constructor(e,t,i={}){const n=Object.assign({},K,i);if(!(e instanceof se))throw new Error("session must be a XRSession");if(e.ended)throw new Error("InvalidStateError");if(t[U]&&!0!==t[G])throw new Error("InvalidStateError");const r=t.getParameter(t.FRAMEBUFFER_BINDING);this[J]={context:t,config:n,framebuffer:r,session:e}}get context(){return this[J].context}get antialias(){return this[J].config.antialias}get ignoreDepthValues(){return!0}get framebuffer(){return this[J].framebuffer}get framebufferWidth(){return this[J].context.drawingBufferWidth}get framebufferHeight(){return this[J].context.drawingBufferHeight}get _session(){return this[J].session}getViewport(e){return e._getViewport(this)}static getNativeFramebufferScaleFactor(e){if(!e)throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");return e[ne].ended?0:1}},XRSpace:S,XRReferenceSpace:R,XRReferenceSpaceEvent:le,XRInputSource:class{constructor(e){this[oe]={impl:e,gripSpace:new S("grip",this),targetRaySpace:new S("target-ray",this)}}get handedness(){return this[oe].impl.handedness}get targetRayMode(){return this[oe].impl.targetRayMode}get gripSpace(){let e=this[oe].impl.targetRayMode;return"gaze"===e||"screen"===e?null:this[oe].gripSpace}get targetRaySpace(){return this[oe].targetRaySpace}get profiles(){return this[oe].impl.profiles}get gamepad(){return this[oe].impl.gamepad}},XRInputSourceEvent:Y,XRInputSourcesChangeEvent:ie,XRRenderState:H,XRRigidTransform:w,XRPose:L};const he=e=>"function"!=typeof e.prototype.makeXRCompatible&&(e.prototype.makeXRCompatible=function(){return this[G]=!0,Promise.resolve()},!0),ue=e=>{const t=e.prototype.getContext;e.prototype.getContext=function(e,i){const n=t.call(this,e,i);return n&&(n[U]=!0,i&&"xrCompatible"in i&&(n[G]=i.xrCompatible)),n}},de=async function(e,t){},pe={global:e,webvr:!0,cardboard:!0,cardboardConfig:null,allowCardboardOnDesktop:!1},fe=["navigator","HTMLCanvasElement","WebGLRenderingContext"];return class{constructor(e={}){this.config=Object.freeze(Object.assign({},pe,e)),this.global=this.config.global,this.nativeWebXR="xr"in this.global.navigator,this.injected=!1,this.nativeWebXR?this._injectCompatibilityShims(this.global):this._injectPolyfill(this.global)}_injectPolyfill(e){if(!fe.every(t=>!!e[t]))throw new Error(`Global must have the following attributes : ${fe}`);for(const t of Object.keys(ce))void 0!==e[t]?console.warn(`${t} already defined on global.`):e[t]=ce[t];he(e.WebGLRenderingContext)&&(ue(e.HTMLCanvasElement),e.OffscreenCanvas&&ue(e.OffscreenCanvas),e.WebGL2RenderingContext&&he(e.WebGL2RenderingContext),window.isSecureContext||console.warn("WebXR Polyfill Warning:\nThis page is not running in a secure context (https:// or localhost)!\nThis means that although the page may be able to use the WebXR Polyfill it will\nnot be able to use native WebXR implementations, and as such will not be able to\naccess dedicated VR or AR hardware, and will not be able to take advantage of\nany performance improvements a native WebXR implementation may offer. Please\nhost this content on a secure origin for the best user experience.\n")),this.injected=!0,this._patchNavigatorXR()}_patchNavigatorXR(){let e=de(this.global,this.config);this.xr=new ce.XRSystem(e),Object.defineProperty(this.global.navigator,"xr",{value:this.xr,configurable:!0})}_injectCompatibilityShims(e){if(!fe.every(t=>!!e[t]))throw new Error(`Global must have the following attributes : ${fe}`);if(e.navigator.xr&&"supportsSession"in e.navigator.xr&&!("isSessionSupported"in e.navigator.xr)){let t=e.navigator.xr.supportsSession;e.navigator.xr.isSessionSupported=function(e){return t.call(this,e).then(()=>!0).catch(()=>!1)},e.navigator.xr.supportsSession=function(e){return console.warn("navigator.xr.supportsSession() is deprecated. Please call navigator.xr.isSessionSupported() instead and check the boolean value returned when the promise resolves."),t.call(this,e)}}}}});
